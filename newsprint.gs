/*******************************
 * NEWSPRINT - Daily News Digest
 * Version: 2.0
 * Author: The Newsprint Project
 * Description: Automated news aggregation with topic monitoring, 
 *              market data, and weather delivered to email/Kindle
 *******************************/

/*******************************
 * CONFIGURATION
 *******************************/

// API Keys
const OPENAI_API_KEY = PropertiesService.getScriptProperties().getProperty('OPENAI_API_KEY');

// Email Settings
const RECIPIENT_EMAIL = "your@email.com";
const KINDLE_EMAIL = "your-kindle@kindle.com"; // Optional - for Kindle delivery
const USE_KINDLE = false; // Set to true to send to Kindle instead

// Geographic Locations for Weather
const LOCATIONS = {
  "San Francisco": { lat: 37.7749, lon: -122.4194 },
  "New York": { lat: 40.7128, lon: -74.0060 },
  "London": { lat: 51.5074, lon: -0.1278 }
};

// RSS News Sources
const NEWS_SOURCES = [
  { name: "Associated Press", url: "https://apnews.com/apf-topnews" },
  { name: "Reuters", url: "https://feeds.reuters.com/reuters/topNews" },
  { name: "New York Times", url: "https://rss.nytimes.com/services/xml/rss/nyt/HomePage.xml" },
  { name: "Wall Street Journal", url: "https://feeds.a.dj.com/rss/RSSWorldNews.xml" },
  { name: "TechCrunch", url: "https://techcrunch.com/feed/" },
  { name: "Hacker News", url: "https://news.ycombinator.com/rss" }
];

// Topic Monitoring (Google Alerts replacement)
// Use quotes for exact phrase matching: "company name"
const ALERT_TOPICS = [
  "\"Artificial Intelligence\"",
  "\"Tech Startups\"",
  "\"San Francisco\"",
  "\"Venture Capital\"",
  "\"Stock Market\"",
  "\"SaaS\"",
  "\"Cloud Computing\"",
  "\"Cybersecurity\"",
  "\"Your Name\""
];

// Market Data
const STOCKS = ["AAPL", "GOOGL", "MSFT", "TSLA"];
const CRYPTO = ["BTC", "ETH", "SOL"];
const FOREX = ["USD/EUR", "GBP/USD"];

/*******************************
 * MAIN FUNCTION - Daily Report
 *******************************/
function dailyReport() {
  Logger.log("Starting daily report generation...");
  
  try {
    // Gather all data
    const news = fetchNewsText();
    const summary = summarizeWithChatGPT(news);
    const weatherReport = fetchWeatherForLocations();
    const alerts = fetchAlerts();
    const marketData = fetchMarketData();
    
    // Build email body
    let emailBody = buildEmailBody(summary, weatherReport, alerts, marketData);
    
    // Send email
    const recipient = USE_KINDLE ? KINDLE_EMAIL : RECIPIENT_EMAIL;
    const subject = USE_KINDLE ? "Daily Digest" : "ðŸ“° Daily News + Weather Report";
    
    GmailApp.sendEmail(
      recipient,
      subject,
      emailBody,
      { 
        name: "Newsprint Daily", 
        replyTo: RECIPIENT_EMAIL 
      }
    );
    
    Logger.log("âœ… Daily report sent successfully!");
    
  } catch (error) {
    Logger.log("âŒ Error in daily report: " + error);
    // Send error notification
    GmailApp.sendEmail(
      RECIPIENT_EMAIL,
      "âŒ Newsprint Error",
      "Daily report failed with error:\n\n" + error
    );
  }
}

/*******************************
 * EMAIL BODY BUILDER
 *******************************/
function buildEmailBody(summary, weather, alerts, marketData) {
  const date = Utilities.formatDate(new Date(), "PST", "EEEE, MMMM d, yyyy");
  
  let body = `NEWSPRINT DAILY DIGEST\n`;
  body += `${date}\n`;
  body += `${"=".repeat(50)}\n\n`;
  
  // News Summary
  body += `ðŸ“° NEWS SUMMARY\n`;
  body += `${"-".repeat(50)}\n`;
  body += `${summary}\n\n`;
  
  // Market Data
  if (marketData) {
    body += `ðŸ“ˆ MARKET UPDATE\n`;
    body += `${"-".repeat(50)}\n`;
    body += `${marketData}\n\n`;
  }
  
  // Weather
  body += `ðŸŒ¤ï¸  WEATHER FORECAST\n`;
  body += `${"-".repeat(50)}\n`;
  body += `${weather}\n\n`;
  
  // Topic Alerts
  if (alerts) {
    body += `ðŸŽ¯ TOPIC ALERTS (Last 12 Hours)\n`;
    body += `${"-".repeat(50)}\n`;
    body += `${alerts}\n\n`;
  }
  
  body += `${"-".repeat(50)}\n`;
  body += `Generated by Newsprint | Delivered with â˜•\n`;
  
  return body;
}

/*******************************
 * RSS NEWS FETCHING
 *******************************/
function fetchNewsText() {
  let allNews = [];
  
  NEWS_SOURCES.forEach(source => {
    try {
      Logger.log(`Fetching from ${source.name}...`);
      const response = UrlFetchApp.fetch(source.url, { muteHttpExceptions: true });
      
      if (response.getResponseCode() !== 200) {
        Logger.log(`Warning: ${source.name} returned ${response.getResponseCode()}`);
        return;
      }
      
      const xml = XmlService.parse(response.getContentText());
      const items = xml.getRootElement().getChild("channel").getChildren("item");
      
      items.slice(0, 10).forEach(item => {
        const title = item.getChild("title")?.getText() || "";
        const description = item.getChild("description")?.getText() || "";
        const link = item.getChild("link")?.getText() || "";
        
        allNews.push({
          source: source.name,
          title: title,
          description: cleanHTML(description),
          link: link
        });
      });
      
    } catch (err) {
      Logger.log(`Error fetching ${source.name}: ${err}`);
    }
  });
  
  // Format for summarization
  return allNews.map(item => 
    `[${item.source}] ${item.title}\n${item.description}`
  ).join("\n\n");
}

function cleanHTML(text) {
  if (!text) return "";
  return text
    .replace(/<[^>]*>/g, "")
    .replace(/&nbsp;/g, " ")
    .replace(/&amp;/g, "&")
    .replace(/&lt;/g, "<")
    .replace(/&gt;/g, ">")
    .replace(/&quot;/g, '"')
    .trim();
}

/*******************************
 * AI SUMMARIZATION
 *******************************/
function summarizeWithChatGPT(newsText) {
  if (!OPENAI_API_KEY) {
    Logger.log("No OpenAI API key - skipping summarization");
    return newsText.substring(0, 2000) + "...\n\n[Configure OpenAI API key for AI summaries]";
  }
  
  const prompt = `You are a news editor creating a daily briefing. Summarize the following news articles into a concise, readable digest. Focus on the most important stories and provide context. Keep it under 500 words.

News articles:
${newsText}`;

  const payload = {
    model: "gpt-4",
    messages: [
      { role: "system", content: "You are a skilled news editor creating daily briefings." },
      { role: "user", content: prompt }
    ],
    max_tokens: 1000,
    temperature: 0.7
  };
  
  try {
    const response = UrlFetchApp.fetch("https://api.openai.com/v1/chat/completions", {
      method: "post",
      headers: {
        "Authorization": "Bearer " + OPENAI_API_KEY,
        "Content-Type": "application/json"
      },
      payload: JSON.stringify(payload),
      muteHttpExceptions: true
    });
    
    const json = JSON.parse(response.getContentText());
    
    if (json.choices && json.choices[0]) {
      return json.choices[0].message.content.trim();
    } else {
      Logger.log("Unexpected API response: " + response.getContentText());
      return newsText.substring(0, 2000) + "...\n\n[Summarization unavailable]";
    }
    
  } catch (err) {
    Logger.log("ChatGPT error: " + err);
    return newsText.substring(0, 2000) + "...\n\n[Summarization error]";
  }
}

/*******************************
 * WEATHER FETCHING
 *******************************/
function fetchWeatherForLocations() {
  let report = [];
  
  for (const [city, coords] of Object.entries(LOCATIONS)) {
    try {
      const weather = fetchWeather(coords.lat, coords.lon);
      report.push(`${city}:\n${weather}`);
    } catch (err) {
      Logger.log(`Weather error for ${city}: ${err}`);
      report.push(`${city}: Weather unavailable`);
    }
  }
  
  return report.join("\n\n");
}

function fetchWeather(lat, lon) {
  const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&daily=temperature_2m_max,temperature_2m_min,precipitation_sum,weathercode&timezone=auto&forecast_days=3`;
  
  const response = UrlFetchApp.fetch(url);
  const data = JSON.parse(response.getContentText());
  
  let forecast = [];
  
  for (let i = 0; i < 3; i++) {
    const date = new Date(data.daily.time[i]);
    const dayName = Utilities.formatDate(date, "PST", "EEE");
    const tempMax = Math.round(data.daily.temperature_2m_max[i]);
    const tempMin = Math.round(data.daily.temperature_2m_min[i]);
    const precip = data.daily.precipitation_sum[i];
    const weatherCode = data.daily.weathercode[i];
    const condition = getWeatherCondition(weatherCode);
    
    forecast.push(`  ${dayName}: ${condition} ${tempMax}Â°/${tempMin}Â°C, Rain: ${precip}mm`);
  }
  
  return forecast.join("\n");
}

function getWeatherCondition(code) {
  const conditions = {
    0: "â˜€ï¸ Clear",
    1: "ðŸŒ¤ï¸ Mainly Clear",
    2: "â›… Partly Cloudy",
    3: "â˜ï¸ Cloudy",
    45: "ðŸŒ«ï¸ Foggy",
    48: "ðŸŒ«ï¸ Foggy",
    51: "ðŸŒ¦ï¸ Light Drizzle",
    61: "ðŸŒ§ï¸ Light Rain",
    63: "ðŸŒ§ï¸ Rain",
    65: "ðŸŒ§ï¸ Heavy Rain",
    71: "ðŸŒ¨ï¸ Light Snow",
    73: "ðŸŒ¨ï¸ Snow",
    75: "ðŸŒ¨ï¸ Heavy Snow",
    95: "â›ˆï¸ Thunderstorm"
  };
  return conditions[code] || "ðŸŒ¡ï¸ Weather";
}

/*******************************
 * TOPIC ALERTS (Google Alerts Replacement)
 *******************************/
function fetchAlerts() {
  const results = [];
  const twelveHoursAgo = new Date();
  twelveHoursAgo.setHours(twelveHoursAgo.getHours() - 12);
  
  Logger.log("Checking topic alerts...");
  
  ALERT_TOPICS.forEach((topic, index) => {
    try {
      Logger.log(`Searching for: ${topic}`);
      const newsItems = searchGoogleNews(topic, twelveHoursAgo);
      
      if (newsItems.length > 0) {
        results.push(`\n[${topic}]`);
        newsItems.forEach(item => {
          results.push(`  â€¢ ${item.title}`);
          if (item.source) results.push(`    (${item.source}, ${item.date})`);
        });
      }
      
      // Rate limiting
      if (index < ALERT_TOPICS.length - 1) {
        Utilities.sleep(800);
      }
      
    } catch (err) {
      Logger.log(`Alert search failed for "${topic}": ${err}`);
    }
  });
  
  if (results.length === 0) {
    return "No news alerts found for monitored topics in the past 12 hours.";
  }
  
  return results.join("\n");
}

function searchGoogleNews(query, sinceDate) {
  const encodedQuery = encodeURIComponent(query);
  
  const urls = [
    `https://news.google.com/rss/search?q=${encodedQuery}&hl=en-US&gl=US&ceid=US:en`
  ];
  
  let allResults = [];
  
  for (const url of urls) {
    try {
      const response = UrlFetchApp.fetch(url, {
        muteHttpExceptions: true,
        followRedirects: true,
        headers: {
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        }
      });
      
      if (response.getResponseCode() !== 200) continue;
      
      const xml = XmlService.parse(response.getContentText());
      const channel = xml.getRootElement().getChild("channel");
      if (!channel) continue;
      
      const items = channel.getChildren("item");
      
      for (let i = 0; i < Math.min(5, items.length); i++) {
        const item = items[i];
        const pubDateElement = item.getChild("pubDate");
        if (!pubDateElement) continue;
        
        const pubDate = new Date(pubDateElement.getText());
        
        if (pubDate >= sinceDate) {
          const titleElement = item.getChild("title");
          const sourceElement = item.getChild("source");
          
          if (titleElement) {
            allResults.push({
              title: titleElement.getText(),
              source: sourceElement ? sourceElement.getText().trim() : "Unknown",
              date: Utilities.formatDate(pubDate, "PST", "MMM d, HH:mm")
            });
          }
        }
      }
      
    } catch (err) {
      Logger.log(`Error searching ${url}: ${err}`);
    }
  }
  
  return allResults;
}

/*******************************
 * MARKET DATA
 *******************************/
function fetchMarketData() {
  let report = [];
  
  // Stocks
  if (STOCKS.length > 0) {
    report.push("STOCKS:");
    STOCKS.forEach(symbol => {
      try {
        const data = fetchStockData(symbol);
        if (data) report.push(formatMarketData(symbol, data));
      } catch (err) {
        Logger.log(`Error fetching ${symbol}: ${err}`);
        report.push(`  ${symbol}: Error fetching data`);
      }
    });
    report.push("");
  }
  
  // Crypto
  if (CRYPTO.length > 0) {
    report.push("CRYPTO:");
    CRYPTO.forEach(symbol => {
      try {
        const data = fetchCryptoData(symbol);
        if (data) report.push(formatMarketData(symbol, data));
      } catch (err) {
        Logger.log(`Error fetching ${symbol}: ${err}`);
        report.push(`  ${symbol}: Error fetching data`);
      }
    });
    report.push("");
  }
  
  // Forex
  if (FOREX.length > 0) {
    report.push("FOREX:");
    FOREX.forEach(pair => {
      try {
        const data = fetchForexData(pair);
        if (data) report.push(formatMarketData(pair, data));
      } catch (err) {
        Logger.log(`Error fetching ${pair}: ${err}`);
        report.push(`  ${pair}: Error fetching data`);
      }
    });
  }
  
  return report.length > 0 ? report.join("\n") : null;
}

const CACHE_DURATION = 1800; // 30 minutes

function fetchWithCache(url, cacheKey) {
  const cache = CacheService.getScriptCache();
  const cached = cache.get(cacheKey);
  if (cached) {
    return JSON.parse(cached);
  }
  const response = UrlFetchApp.fetch(url, { muteHttpExceptions: true });
  const data = response.getContentText();
  cache.put(cacheKey, data, CACHE_DURATION);
  return JSON.parse(data);
}

function fetchStockData(symbol) {
  const url = `https://query1.finance.yahoo.com/v8/finance/chart/${symbol}?interval=1d&range=1y`;
  const data = fetchWithCache(url, `stock_${symbol}`);
  
  if (!data.chart || !data.chart.result || !data.chart.result[0]) return null;
  
  const result = data.chart.result[0];
  const currentPrice = result.meta.regularMarketPrice;
  const previousClose = result.meta.chartPreviousClose;
  
  return {
    price: currentPrice,
    change_24h: ((currentPrice - previousClose) / previousClose) * 100,
    change_7d: calculateChange(result, 7),
    change_30d: calculateChange(result, 30),
    change_1y: calculateChange(result, 365)
  };
}

function fetchCryptoData(symbol) {
  const cryptoIds = { BTC: "bitcoin", ETH: "ethereum", SOL: "solana" };
  const id = cryptoIds[symbol] || symbol.toLowerCase();
  
  const url = `https://api.coincap.io/v2/assets/${id}`;
  const data = fetchWithCache(url, `crypto_${symbol}`);
  
  return {
    price: parseFloat(data.data.priceUsd),
    change_24h: parseFloat(data.data.changePercent24Hr),
    change_7d: null,
    change_30d: null,
    change_1y: null
  };
}

function fetchForexData(pair) {
  const [from, to] = pair.split("/");
  const url = `https://query1.finance.yahoo.com/v8/finance/chart/${from}${to}=X?interval=1d&range=1y`;
  const data = fetchWithCache(url, `forex_${pair}`);
  
  if (!data.chart || !data.chart.result || !data.chart.result[0]) return null;
  
  const result = data.chart.result[0];
  const currentPrice = result.meta.regularMarketPrice;
  const previousClose = result.meta.chartPreviousClose;
  
  return {
    price: currentPrice,
    change_24h: ((currentPrice - previousClose) / previousClose) * 100,
    change_7d: calculateChange(result, 7),
    change_30d: calculateChange(result, 30),
    change_1y: calculateChange(result, 365)
  };
}

function calculateChange(chartData, days) {
  try {
    const closes = chartData.indicators.quote[0].close;
    if (!closes || closes.length < days) return null;
    
    const current = closes[closes.length - 1];
    const past = closes[closes.length - days];
    
    if (!current || !past) return null;
    
    return ((current - past) / past) * 100;
  } catch (err) {
    return null;
  }
}

function formatMarketData(symbol, data) {
  const formatChange = (change) => {
    if (change === null) return "N/A";
    const sign = change >= 0 ? "+" : "";
    return `${sign}${change.toFixed(2)}%`;
  };
  
  const formatPrice = (price) => {
    if (price >= 1000) return `$${price.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})}`;
    if (price >= 1) return `$${price.toFixed(2)}`;
    return `$${price.toFixed(4)}`;
  };
  
  return `  ${symbol}: ${formatPrice(data.price)} | ` +
         `1D: ${formatChange(data.change_24h)} | ` +
         `1W: ${formatChange(data.change_7d)} | ` +
         `1M: ${formatChange(data.change_30d)} | ` +
         `1Y: ${formatChange(data.change_1y)}`;
}

/*******************************
 * UTILITY FUNCTIONS
 *******************************/

// Test function - run this to test your configuration
function testReport() {
  Logger.log("Running test report...");
  dailyReport();
  Logger.log("Check your email!");
}

// Manual trigger for specific sections
function testNewsOnly() {
  const news = fetchNewsText();
  Logger.log(news);
}

function testWeatherOnly() {
  const weather = fetchWeatherForLocations();
  Logger.log(weather);
}

function testAlertsOnly() {
  const alerts = fetchAlerts();
  Logger.log(alerts);
}

function testMarketOnly() {
  const market = fetchMarketData();
  Logger.log(market);
}
